{"version":3,"sources":["Engine/Node/Node.jsx","Algorithms/dijkstra.js","Algorithms/astar.js","Engine/Engine.jsx","App.js","index.js"],"names":["Node","_Component","props","_this","_classCallCheck","this","_possibleConstructorReturn","_getPrototypeOf","call","state","_inherits","_createClass","key","value","_this$props","col","isDestination","isWall","onMouseDown","onMouseEnter","onMouseUp","row","isVisited","distance","extraClassName","heuristic","React","createElement","id","concat","className","e","Infinity","Component","dijkstra","grid","start","finish","vistedNodesIO","unvisitedNodes","_step","nodes","_iterator","_createForOfIteratorHelper","s","n","done","_step2","_iterator2","node","push","err","f","getAllNodes","length","sortNodesByDistance","closestNode","shift","updateUnvisitedNeighbors","sort","nodeA","nodeB","_step3","_iterator3","neighbors","filter","neighbor","getUnvisitedNeighbors","previousNode","getNodesInShortestPathOrder","finishNode","nodesInShortestPathOrder","currentNode","unshift","manhattanDistance","Math","abs","aStar","visitedNodesInOrder","console","log","sortNodesByHeuristic","tentativeDistance","Engine","addDestinationNode","_this$state","destinationNodes","isAnimating","newGrid","slice","isSelected","color","nodeIndex","findIndex","splice","selectedNodes","flat","oldestNode","reduce","prev","curr","isSelectedAt","Date","now","setState","forEach","handleMouseDown","shiftKeyPressed","getNewGridWithWallToggled","mouseIsPressed","handleKeyDown","handleKeyUp","clearGrid","getInitialGrid","document","getElementsByClassName","i","nodeClassName","setAttribute","clearGridExceptDestinations","updateGrid","_this$state2","startNodeRow","startNodeCol","finishNodeRow","finishNodeCol","oldStartNode","find","isStart","oldFinishNode","isFinish","bind","_assertThisInitialized","handleMouseEnter","addEventListener","removeEventListener","visitedNodesInOrderList","_this2","_loop","setTimeout","animateShortestPath","v","element","getElementById","_ret","_loop2","_this$state3","isEmpty","alert","startNode","animatePathfinding","_this$state4","_this3","Fragment","map","rowIdx","nodeIdx","handleMouseUp","onClick","visualizeDijkstra","disabled","visualizeAStar","currentRow","createNode","newNode","_objectSpread","App","ReactDOM","createRoot","render","StrictMode"],"mappings":"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","file":"static/js/main.18a4e118.chunk.js","sourcesContent":["import React, {Component} from 'react';\n\nimport './Node.css';\n\nexport default class Node extends Component {\n\n    constructor(props) {\n\n        super(props); \n        this.state = {};\n    }\n\n    render() {\n\n        const {\n\n            col,\n            isDestination,\n            isWall,\n            onMouseDown,\n            onMouseEnter,\n            onMouseUp,\n            row,\n            isVisited, \n            distance, \n            heuristic,\n        \n        } = this.props;\n\n        const extraClassName =\n\n            isDestination ? \"node-destination\" : isWall ? \"node-wall\" : \"\";\n\n            return <div id={\n            \n            `node-${row}-${col}`}\n            className={`node ${extraClassName}`}\n            onMouseDown={(e) => onMouseDown(row, col, e)}\n            onMouseEnter={(e) => onMouseEnter(row, col, e)}\n            onMouseUp={() => onMouseUp()}>\n                \n\n            {isVisited && distance !== Infinity && (\n                <span className=\"node-distance\">{distance}</span>\n            )}\n\n        </div>;\n    }\n}","\n//FOR NOW CODING DJKSTRAS TO GET THE FOUNDATION THEN UPDATING TO ASTAR\n\nexport function dijkstra(grid, start, finish) {\n\n    const vistedNodesIO = [];\n    start.distance = 0;\n    const unvisitedNodes = getAllNodes(grid);\n\n    while (!!unvisitedNodes.length) {\n\n        sortNodesByDistance(unvisitedNodes);\n\n        const closestNode = unvisitedNodes.shift();\n\n        // If we encounter a wall, we skip it.\n        if (closestNode.isWall) continue;\n\n        // If the closest node is at a distance of infinity,\n        // we must be trapped and should therefore stop.\n        if (closestNode.distance === Infinity) return vistedNodesIO;\n\n        closestNode.isVisited = true;\n\n        vistedNodesIO.push(closestNode);\n\n        if (closestNode === finish) return vistedNodesIO;\n\n        updateUnvisitedNeighbors(closestNode, grid);\n    }\n}\n\nfunction getAllNodes(grid) {\n\n    const nodes = [];\n    for(const row of grid) {\n\n        for(const node of row) {\n\n            nodes.push(node);\n        }\n    }\n\n    return nodes;\n}\n\nfunction sortNodesByDistance(unvisitedNodes) {\n\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n\n    const neighbors = [];\n    const {col, row} = node;\n\n    if (row > 0) \n\n        neighbors.push(grid[row - 1][col]);\n\n    if (row < grid.length - 1) \n    \n        neighbors.push(grid[row + 1][col]);\n\n    if (col > 0) \n\n        neighbors.push(grid[row][col - 1]);\n\n    if (col < grid[0].length - 1) \n\n        neighbors.push(grid[row][col + 1]);\n\n    return neighbors.filter(neighbor => !neighbor.isVisited);\n\n}\n\nfunction updateUnvisitedNeighbors(node, grid) {\n\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n\n    for (const neighbor of unvisitedNeighbors) {\n\n      neighbor.distance = node.distance + 1;\n      neighbor.previousNode = node;\n\n    }\n}\n\nexport function getNodesInShortestPathOrder(finishNode) {\n\n    const nodesInShortestPathOrder = [];\n\n    let currentNode = finishNode;\n\n    while (currentNode !== null) {\n\n      nodesInShortestPathOrder.unshift(currentNode);\n      currentNode = currentNode.previousNode;\n\n    }\n\n    return nodesInShortestPathOrder;\n}","function manhattanDistance(nodeA, nodeB) {\r\n\r\n    return Math.abs(nodeA.row - nodeB.row) + Math.abs(nodeA.col - nodeB.col);\r\n  }\r\n  \r\nexport function aStar(grid, start, finish) {\r\n    \r\n    const visitedNodesInOrder = [];\r\n    start.distance = 0;\r\n    start.heuristic = manhattanDistance(start, finish);\r\n    const unvisitedNodes = getAllNodes(grid);\r\n  \r\n    console.log('Grid:', grid);\r\n    console.log('Start node:', start);\r\n    console.log('Finish node:', finish);\r\n  \r\n    while (unvisitedNodes.length) {\r\n      sortNodesByHeuristic(unvisitedNodes);\r\n  \r\n      const closestNode = unvisitedNodes.shift();\r\n  \r\n      if (closestNode.isWall) continue;\r\n  \r\n      if (closestNode.distance === Infinity) {\r\n        console.log('Visited nodes in order (trapped):', visitedNodesInOrder);\r\n        return visitedNodesInOrder;\r\n      }\r\n  \r\n      closestNode.isVisited = true;\r\n      visitedNodesInOrder.push(closestNode);\r\n  \r\n      if (closestNode === finish) {\r\n        console.log('Visited nodes in order (path found):', visitedNodesInOrder);\r\n        return visitedNodesInOrder;\r\n      }\r\n  \r\n      updateUnvisitedNeighbors(closestNode, grid, finish);\r\n    }\r\n}\r\n  \r\nfunction sortNodesByHeuristic(unvisitedNodes) {\r\n\r\n    unvisitedNodes.sort(\r\n      (nodeA, nodeB) =>\r\n        nodeA.distance + nodeA.heuristic - (nodeB.distance + nodeB.heuristic)\r\n    );\r\n}\r\n  \r\nfunction updateUnvisitedNeighbors(node, grid, finish) {\r\n\r\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n  \r\n    for (const neighbor of unvisitedNeighbors) {\r\n      const tentativeDistance = node.distance + 1;\r\n  \r\n      if (tentativeDistance < neighbor.distance) {\r\n        neighbor.distance = tentativeDistance;\r\n        neighbor.heuristic = manhattanDistance(neighbor, finish);\r\n        neighbor.previousNode = node;\r\n      }\r\n    }\r\n}\r\n\r\nexport function getNodesInShortestPathOrder(finishNode) {\r\n\r\n    const nodesInShortestPathOrder = [];\r\n\r\n    let currentNode = finishNode;\r\n\r\n    while (currentNode !== null) {\r\n\r\n      nodesInShortestPathOrder.unshift(currentNode);\r\n      currentNode = currentNode.previousNode;\r\n\r\n    }\r\n\r\n    return nodesInShortestPathOrder;\r\n}\r\n\r\nfunction getAllNodes(grid) {\r\n\r\n    const nodes = [];\r\n    for(const row of grid) {\r\n\r\n        for(const node of row) {\r\n\r\n            nodes.push(node);\r\n        }\r\n    }\r\n\r\n    return nodes;\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n\r\n    const neighbors = [];\r\n    const {col, row} = node;\r\n\r\n    if (row > 0) \r\n\r\n        neighbors.push(grid[row - 1][col]);\r\n\r\n    if (row < grid.length - 1) \r\n    \r\n        neighbors.push(grid[row + 1][col]);\r\n\r\n    if (col > 0) \r\n\r\n        neighbors.push(grid[row][col - 1]);\r\n\r\n    if (col < grid[0].length - 1) \r\n\r\n        neighbors.push(grid[row][col + 1]);\r\n\r\n    return neighbors.filter(neighbor => !neighbor.isVisited);\r\n\r\n}","import React, { Component } from \"react\";\nimport Node from \"./Node/Node\";\n\nimport { dijkstra, getNodesInShortestPathOrder } from \"../Algorithms/dijkstra\";\nimport { aStar } from \"../Algorithms/astar\";\n\nimport \"./Engine.css\";\n\n\nexport default class Engine extends Component {\n  \n  constructor() {\n    \n    super();\n\n    this.state = {\n      grid: [],\n      destinationNodes: [],\n      isAnimating: false,\n    };\n\n    this.clearGrid = this.clearGrid.bind(this);\n    this.addDestinationNode = this.addDestinationNode.bind(this);\n    this.handleMouseDown = this.handleMouseDown.bind(this);\n    this.handleMouseEnter = this.handleMouseEnter.bind(this);\n  }\n\n  addDestinationNode = (row, col) => {\n    const { grid, destinationNodes, isAnimating } = this.state;\n    const newGrid = grid.slice();\n    const node = newGrid[row][col];\n\n    if (isAnimating) {\n      return;\n    }\n  \n    console.log(\"Clicked node:\", node);\n  \n    // Check if the node is already selected\n    if (node.isSelected) {\n      console.log(\"Node is already selected, deselecting it...\");\n      node.color = \"destination\";\n      node.isSelected = false;\n      node.isDestination = false; // Reset isDestination when deselecting node\n      const nodeIndex = destinationNodes.findIndex(\n        (n) => n.row === row && n.col === col\n      );\n      if (nodeIndex !== -1) {\n        // Remove the node from the destinationNodes array\n        destinationNodes.splice(nodeIndex, 1);\n      }\n    } else {\n      console.log(\"Node is not selected, selecting it...\");\n  \n      // Check if there are already two destination nodes selected\n      const selectedNodes = newGrid\n        .flat()\n        .filter((node) => node.color === \"node-destination\" && node.isSelected);\n      if (selectedNodes.length === 2) {\n        // Deselect the oldest selected node\n        const oldestNode = selectedNodes.reduce((prev, curr) =>\n          prev.isSelectedAt < curr.isSelectedAt ? prev : curr\n        );\n        oldestNode.color = \"destination\";\n        oldestNode.isSelected = false;\n        oldestNode.isDestination = false; // Reset isDestination when deselecting node\n        const nodeIndex = destinationNodes.findIndex(\n          (n) => n.row === oldestNode.row && n.col === oldestNode.col\n        );\n        if (nodeIndex !== -1) {\n          // Remove the node from the destinationNodes array\n          destinationNodes.splice(nodeIndex, 1);\n        }\n      }\n  \n      // Select the new destination node\n      node.color = \"node-destination\";\n      node.isSelected = true;\n      node.isSelectedAt = Date.now();\n      node.isDestination = true;\n      node.className = node.isSelected ? \"node node-destination\" : \"node destination\";\n      destinationNodes.push(node);\n    }\n  \n    this.setState({ grid: newGrid, destinationNodes });\n  \n    console.log(\"Destination nodes:\");\n    destinationNodes.forEach((node) => {\n      console.log(`(${node.row}, ${node.col})`);\n    });\n  };\n  \n\n  componentDidMount() {\n\n    const grid = getInitialGrid();\n    this.setState({ grid });\n    document.addEventListener(\"keydown\", this.handleKeyDown);\n    document.addEventListener(\"keyup\", this.handleKeyUp);\n  }\n\n  componentWillUnmount() {\n    document.removeEventListener(\"keydown\", this.handleKeyDown);\n    document.removeEventListener(\"keyup\", this.handleKeyUp);\n  }\n  \n  handleMouseDown = (row, col, e) => {\n\n    if (this.state.isAnimating) {\n      // If animation is running, do nothing\n      return;\n    }\n\n    if (!this.state.shiftKeyPressed) {\n      this.addDestinationNode(row, col);\n    } else {\n      const newGrid = getNewGridWithWallToggled(this.state.grid, row, col, e);\n      this.setState({ grid: newGrid, mouseIsPressed: true });\n    }\n  };\n\n  handleMouseEnter(row, col, e) {\n    if (this.state.isAnimating || !this.state.mouseIsPressed || !this.state.shiftKeyPressed) {return;}\n    const newGrid = getNewGridWithWallToggled(this.state.grid, row, col, e);\n    this.setState({ grid: newGrid });\n  }\n\n  handleMouseUp() {\n    this.setState({ mouseIsPressed: false });\n  }\n\n  handleMouseLeave(row, col) {\n    if (!this.state.mouseIsPressed) return;\n    this.setState({ mouseIsPressed: false });\n  }\n\n  handleKeyDown = (e) => {\n    if (e.key === \"Shift\") {\n      this.setState({ shiftKeyPressed: true });\n    }\n  };\n\n  handleKeyUp = (e) => {\n    if (e.key === \"Shift\") {\n      this.setState({ shiftKeyPressed: false });\n    }\n  };\n\n  animatePathfinding(visitedNodesInOrderList, nodesInShortestPathOrder) {\n    this.setState({ isAnimating: true });\n  \n    for (let i = 0; i <= visitedNodesInOrderList.length; i++) {\n      if (i === visitedNodesInOrderList.length) {\n        setTimeout(() => {\n          this.animateShortestPath(nodesInShortestPathOrder);\n          this.setState({ isAnimating: false });\n        }, 10 * i);\n  \n        return;\n      }\n  \n      setTimeout(() => {\n        const node = visitedNodesInOrderList[i];\n        const element = document.getElementById(`node-${node.row}-${node.col}`);\n  \n        if (\n          element.className !== \"node node-start\" &&\n          element.className !== \"node node-finish\"\n        ) {\n          document.getElementById(`node-${node.row}-${node.col}`).className =\n            \"node node-visited\";\n        }\n      }, 10 * i);\n    }\n  }\n  \n  animateShortestPath(nodesInShortestPathOrder) {\n\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      setTimeout(() => {\n        const node = nodesInShortestPathOrder[i];\n        const element = document.getElementById(`node-${node.row}-${node.col}`);\n  \n        if (\n          element.className !== \"node node-start\" &&\n          element.className !== \"node node-finish\"\n        ) {\n          document.getElementById(`node-${node.row}-${node.col}`).className =\n            \"node node-shortest-path\";\n        }\n      }, 20 * i);\n    }\n  \n    this.setState({ isAnimating: false });\n  }\n\n  isEmpty() {\n\n    const { grid } = this.state;\n\n    for (let row = 0; row < grid.length; row++) {\n\n      for (let col = 0; col < grid[0].length; col++) {\n\n        const node = grid[row][col];\n\n        console.log(`Node at row ${row} col ${col} has class ${node.className}`);\n\n        if (node.className !== \"node\" || node.className !== null) {\n\n          console.log(\"Node is not empty!\");\n          return false;\n        }\n      }\n    }\n\n    console.log(\"Grid is empty!\");\n    return true;\n  }\n\n  isDestination(node) {\n    return node.className === \"node node-destination\";\n  }\n\n  visualizeDijkstra() {\n\n    console.log(\"Starting visualizeDijkstra()...\");\n    const { grid, destinationNodes } = this.state;\n\n    if(this.isEmpty()) {\n  \n        alert(\"Please add some walls to the grid!\");\n    }\n\n\n    if(destinationNodes.length !== 2) {\n\n      alert(\"Please select two destination nodes!\");\n      return;\n\n    }\n    \n    const startNode = grid[destinationNodes[0].row][destinationNodes[0].col];\n    const finishNode = grid[destinationNodes[1].row][destinationNodes[1].col];\n    const visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n    this.animatePathfinding(visitedNodesInOrder, nodesInShortestPathOrder);\n    this.setState({ isAnimating: true });\n  }\n\n  visualizeAStar() {\n\n    console.log(\"Starting visualizeAStar()...\");\n    const { grid, destinationNodes } = this.state;\n\n    if(this.isEmpty()) {\n  \n        alert(\"Please add some walls to the grid!\");\n    }\n\n\n    if(destinationNodes.length !== 2) {\n\n      alert(\"Please select two destination nodes!\");\n      return;\n\n    }\n    \n    const startNode = grid[destinationNodes[0].row][destinationNodes[0].col];\n    const finishNode = grid[destinationNodes[1].row][destinationNodes[1].col];\n    const visitedNodesInOrder = aStar(grid, startNode, finishNode);\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n    this.animatePathfinding(visitedNodesInOrder, nodesInShortestPathOrder);\n    this.setState({ isAnimating: true });\n  }\n\n  clearGrid = () => {\n    console.log(\"Clearing grid...\");\n    \n    // Reset the grid\n    const newGrid = getInitialGrid();\n  \n    this.setState({ grid: newGrid }, () => {\n      const nodes = document.getElementsByClassName(\"node\");\n  \n      for (let i = 0; i < nodes.length; i++) {\n        const nodeClassName = nodes[i].className;\n        console.log(\"Node class name:\", nodeClassName);\n  \n        if (\n          nodeClassName !== \"node node-destination\"\n        ) {\n          nodes[i].className = \"node\"; // Reset the className of each Node\n          nodes[i].setAttribute(\"key\", `${nodes[i].id}`); // Update the key prop value of each Node\n          console.log(\"Node reset.\");\n        } else {\n          console.log(\"Node is Start or Finish\");\n          continue;\n        }\n      }\n  \n      this.setState({ destinationNodes: [] });\n      console.log(\"Destination nodes cleared.\");\n    });\n  };\n\n  clearGridExceptDestinations = () => {\n    \n    // Reset the grid\n    const newGrid = getInitialGrid();\n\n    this.setState({ grid: newGrid }, () => {\n      const nodes = document.getElementsByClassName(\"node\");\n\n      for (let i = 0; i < nodes.length; i++) {\n\n        const nodeClassName = nodes[i].className;\n\n        if (nodeClassName === \"node node-destination\") {\n\n          nodes[i].className = \"node\"; // Reset the className of each Node\n          nodes[i].setAttribute(\"key\", `${nodes[i].id}`); // Update the key prop value of each Node\n\n        } else {\n\n          console.log(\"Node is Start or Finish\");\n          continue;\n\n        }\n      }\n\n      this.setState({ destinationNodes: [] });\n    });\n  };\n\n  updateGrid = () => {\n    const { grid, startNodeRow, startNodeCol, finishNodeRow, finishNodeCol } =\n      this.state;\n    const newGrid = grid.slice(); // Create a copy of the grid array\n\n    // Remove the old start/finish nodes\n    const oldStartNode = grid.find((row) => row.find((node) => node.isStart));\n    const oldFinishNode = grid.find((row) => row.find((node) => node.isFinish));\n\n    if (oldStartNode) {\n      oldStartNode[\n        oldStartNode.findIndex((node) => node.isStart)\n      ].isStart = false;\n    }\n\n    if (oldFinishNode) {\n      oldFinishNode[\n        oldFinishNode.findIndex((node) => node.isFinish)\n      ].isFinish = false;\n    }\n\n    // Update the start and finish nodes in the newGrid array\n    newGrid[startNodeRow][startNodeCol].isStart = true;\n    newGrid[startNodeRow][startNodeCol].color = \"start\";\n    newGrid[finishNodeRow][finishNodeCol].isFinish = true;\n    newGrid[finishNodeRow][finishNodeCol].color = \"finish\";\n\n    // Update the state with the new grid array\n    this.setState({ grid: newGrid });\n  };\n\n  render() {\n    const { grid } = this.state;\n\n    return (\n      <>\n        <div id=\"header\">\n\n        <div id=\"directions\">\n            click on a node to make it a destination node <br />\n            hold shift and drag to make a wall <br />\n            press an algorithm to visualize the path <br />\n            press the reset button to clear the grid <br />\n        </div>\n\n        <div id=\"destination-node-display\">\n            <h3>Destination Nodes:</h3>\n            {grid.map((row, rowIdx) => {\n              return (\n                <div key={rowIdx}>\n                  {row\n                    .filter((node) => node.color === \"node-destination\")\n                    .map((node, nodeIdx) => (\n                      <span key={nodeIdx}>\n                        ({node.row}, {node.col})\n                      </span>\n                    ))}\n                </div>\n              );\n            })}\n        </div>\n        </div>\n        <div className=\"grid\">\n          {grid.map((row, rowIdx) => {\n            return (\n              <div key={rowIdx}>\n                {row.map((node, nodeIdx) => {\n                  const {\n                    row,\n                    col,\n                    isDestination,\n                    isWall,\n                    isVisited,\n                    distance,\n                    heuristic,\n                  } = node;\n                  return (\n                    <Node\n                      key={`${row}-${col}`}\n                      col={col}\n                      isDestination={isDestination}\n                      isWall={isWall}\n                      row={row}\n                      isVisited={isVisited}\n                      distance={distance}\n                      heuristic={heuristic}\n                      isAnimating={this.state.isAnimating}\n                      onMouseDown={(e) => this.handleMouseDown(row, col, e)}\n                      onMouseEnter={(e) => this.handleMouseEnter(row, col, e)}\n                      onMouseUp={() => this.handleMouseUp()}\n                    ></Node>\n                  );\n                })}\n              </div>\n            );\n          })}\n\n          <div id=\"buttons\">\n            <button onClick={() => this.visualizeDijkstra()} disabled={this.state.isAnimating}>D I J K S T R A</button>\n            <button onClick={() => this.visualizeAStar()} disabled={this.state.isAnimating}>A S T A R</button>\n            <button onClick={() => this.clearGrid()} disabled={this.state.isAnimating}>R E S E T</button>\n          </div>\n        </div>\n      </>\n    );\n  }\n}\n\nconst getInitialGrid = () => {\n  const grid = [];\n  for (let row = 0; row < 20; row++) {\n    const currentRow = [];\n    for (let col = 0; col < 50; col++) {\n      currentRow.push(createNode(col, row));\n    }\n    grid.push(currentRow);\n  }\n  return grid;\n};\n\nconst createNode = (col, row, isStart, isDestination, color, isSelected) => {\n  return {\n    col,\n    row,\n    isStart,\n    isDestination,\n    distance: Infinity,\n    isVisited: false,\n    isWall: false,\n    previousNode: null,\n    heuristic: Infinity,\n    color,\n    isSelected,\n  };\n};\n\nconst getNewGridWithWallToggled = (grid, row, col) => {\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n\n  const newNode = {\n    ...node,\n    isWall: !node.isWall,\n  };\n  newGrid[row][col] = newNode;\n\n  return newGrid;\n};\n","import React from 'react';\nimport './App.css';\nimport Engine from './Engine/Engine'\n\nfunction App() {\n\n  return (\n    \n    <div className='container'>\n      \n      <Engine></Engine>\n\n    </div>\n\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport './index.css';\nimport App from './App';\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\n\nroot.render(\n\n  <React.StrictMode>\n    <App/>\n  </React.StrictMode>\n  \n);\n"],"sourceRoot":""}