{"version":3,"sources":["Engine/Node/Node.jsx","Algorithms/dijkstra.js","Engine/Engine.jsx","App.js","index.js"],"names":["Node","_Component","props","_this","_classCallCheck","this","_possibleConstructorReturn","_getPrototypeOf","call","state","_inherits","_createClass","key","value","_this$props","col","isDestination","isWall","onMouseDown","onMouseEnter","onMouseUp","row","isVisited","distance","extraClassName","React","createElement","id","concat","className","e","Infinity","Component","dijkstra","grid","start","finish","vistedNodesIO","unvisitedNodes","_step","nodes","_iterator","_createForOfIteratorHelper","s","n","done","_step2","_iterator2","node","push","err","f","getAllNodes","length","sortNodesByDistance","closestNode","shift","updateUnvisitedNeighbors","sort","nodeA","nodeB","_step3","_iterator3","neighbors","filter","neighbor","getUnvisitedNeighbors","previousNode","Engine","addDestinationNode","_this$state","destinationNodes","isAnimating","newGrid","slice","console","log","isSelected","color","nodeIndex","findIndex","splice","selectedNodes","flat","oldestNode","reduce","prev","curr","isSelectedAt","Date","now","setState","forEach","handleMouseDown","shiftKeyPressed","getNewGridWithWallToggled","mouseIsPressed","handleKeyDown","handleKeyUp","clearGrid","getInitialGrid","document","getElementsByClassName","i","nodeClassName","setAttribute","clearGridExceptDestinations","updateGrid","_this$state2","startNodeRow","startNodeCol","finishNodeRow","finishNodeCol","oldStartNode","find","isStart","oldFinishNode","isFinish","bind","_assertThisInitialized","handleMouseEnter","addEventListener","removeEventListener","visitedNodesInOrder","nodesInShortestPathOrder","_this2","_loop","setTimeout","animateShortestPath","v","getElementById","_ret","_loop2","_this$state3","isEmpty","alert","startNode","finishNode","currentNode","unshift","getNodesInShortestPathOrder","animateDijkstra","_this3","Fragment","map","rowIdx","nodeIdx","handleMouseUp","onClick","visualizeDijkstra","disabled","currentRow","createNode","newNode","_objectSpread","App","ReactDOM","createRoot","render","StrictMode"],"mappings":"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","file":"static/js/main.482c7064.chunk.js","sourcesContent":["import React, {Component} from 'react';\n\nimport './Node.css';\n\nexport default class Node extends Component {\n\n    constructor(props) {\n\n        super(props); \n        this.state = {};\n    }\n\n    render() {\n\n        const {\n\n            col,\n            isDestination,\n            isWall,\n            onMouseDown,\n            onMouseEnter,\n            onMouseUp,\n            row,\n            isVisited, // Add isVisited here\n            distance, // Add distance here\n        \n        } = this.props;\n\n        const extraClassName =\n\n            isDestination ? \"node-destination\" : isWall ? \"node-wall\" : \"\";\n\n            return <div id={\n            \n            `node-${row}-${col}`}\n            className={`node ${extraClassName}`}\n            onMouseDown={(e) => onMouseDown(row, col, e)}\n            onMouseEnter={(e) => onMouseEnter(row, col, e)}\n            onMouseUp={() => onMouseUp()}>\n                \n\n            {isVisited && distance !== Infinity && (\n                <span className=\"node-distance\">{distance}</span>\n            )}\n\n        </div>;\n    }\n}","\n//FOR NOW CODING DJKSTRAS TO GET THE FOUNDATION THEN UPDATING TO ASTAR\n\nexport function dijkstra(grid, start, finish) {\n\n    const vistedNodesIO = [];\n    start.distance = 0;\n    const unvisitedNodes = getAllNodes(grid);\n\n    while (!!unvisitedNodes.length) {\n\n        sortNodesByDistance(unvisitedNodes);\n\n        const closestNode = unvisitedNodes.shift();\n\n        // If we encounter a wall, we skip it.\n        if (closestNode.isWall) continue;\n\n        // If the closest node is at a distance of infinity,\n        // we must be trapped and should therefore stop.\n        if (closestNode.distance === Infinity) return vistedNodesIO;\n\n        closestNode.isVisited = true;\n\n        vistedNodesIO.push(closestNode);\n\n        if (closestNode === finish) return vistedNodesIO;\n\n        updateUnvisitedNeighbors(closestNode, grid);\n    }\n}\n\nfunction getAllNodes(grid) {\n\n    const nodes = [];\n    for(const row of grid) {\n\n        for(const node of row) {\n\n            nodes.push(node);\n        }\n    }\n\n    return nodes;\n}\n\nfunction sortNodesByDistance(unvisitedNodes) {\n\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n\n    const neighbors = [];\n    const {col, row} = node;\n\n    if (row > 0) \n\n        neighbors.push(grid[row - 1][col]);\n\n    if (row < grid.length - 1) \n    \n        neighbors.push(grid[row + 1][col]);\n\n    if (col > 0) \n\n        neighbors.push(grid[row][col - 1]);\n\n    if (col < grid[0].length - 1) \n\n        neighbors.push(grid[row][col + 1]);\n\n    return neighbors.filter(neighbor => !neighbor.isVisited);\n\n}\n\nfunction updateUnvisitedNeighbors(node, grid) {\n\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n\n    for (const neighbor of unvisitedNeighbors) {\n\n      neighbor.distance = node.distance + 1;\n      neighbor.previousNode = node;\n\n    }\n}\n\nexport function getNodesInShortestPathOrder(finishNode) {\n\n    const nodesInShortestPathOrder = [];\n\n    let currentNode = finishNode;\n\n    while (currentNode !== null) {\n\n      nodesInShortestPathOrder.unshift(currentNode);\n      currentNode = currentNode.previousNode;\n\n    }\n\n    return nodesInShortestPathOrder;\n}","import React, { Component } from \"react\";\nimport Node from \"./Node/Node\";\n\nimport { dijkstra, getNodesInShortestPathOrder } from \"../Algorithms/dijkstra\";\n\nimport \"./Engine.css\";\n\n\nexport default class Engine extends Component {\n  \n  constructor() {\n    \n    super();\n\n    this.state = {\n      grid: [],\n      destinationNodes: [],\n      isAnimating: false,\n    };\n\n    this.clearGrid = this.clearGrid.bind(this);\n    this.addDestinationNode = this.addDestinationNode.bind(this);\n    this.handleMouseDown = this.handleMouseDown.bind(this);\n    this.handleMouseEnter = this.handleMouseEnter.bind(this);\n  }\n\n  addDestinationNode = (row, col) => {\n    const { grid, destinationNodes, isAnimating } = this.state;\n    const newGrid = grid.slice();\n    const node = newGrid[row][col];\n\n    if (isAnimating) {\n      return;\n    }\n  \n    console.log(\"Clicked node:\", node);\n  \n    // Check if the node is already selected\n    if (node.isSelected) {\n      console.log(\"Node is already selected, deselecting it...\");\n      node.color = \"destination\";\n      node.isSelected = false;\n      node.isDestination = false; // Reset isDestination when deselecting node\n      const nodeIndex = destinationNodes.findIndex(\n        (n) => n.row === row && n.col === col\n      );\n      if (nodeIndex !== -1) {\n        // Remove the node from the destinationNodes array\n        destinationNodes.splice(nodeIndex, 1);\n      }\n    } else {\n      console.log(\"Node is not selected, selecting it...\");\n  \n      // Check if there are already two destination nodes selected\n      const selectedNodes = newGrid\n        .flat()\n        .filter((node) => node.color === \"node-destination\" && node.isSelected);\n      if (selectedNodes.length === 2) {\n        // Deselect the oldest selected node\n        const oldestNode = selectedNodes.reduce((prev, curr) =>\n          prev.isSelectedAt < curr.isSelectedAt ? prev : curr\n        );\n        oldestNode.color = \"destination\";\n        oldestNode.isSelected = false;\n        oldestNode.isDestination = false; // Reset isDestination when deselecting node\n        const nodeIndex = destinationNodes.findIndex(\n          (n) => n.row === oldestNode.row && n.col === oldestNode.col\n        );\n        if (nodeIndex !== -1) {\n          // Remove the node from the destinationNodes array\n          destinationNodes.splice(nodeIndex, 1);\n        }\n      }\n  \n      // Select the new destination node\n      node.color = \"node-destination\";\n      node.isSelected = true;\n      node.isSelectedAt = Date.now();\n      node.isDestination = true;\n      node.className = node.isSelected ? \"node node-destination\" : \"node destination\";\n      destinationNodes.push(node);\n    }\n  \n    this.setState({ grid: newGrid, destinationNodes });\n  \n    console.log(\"Destination nodes:\");\n    destinationNodes.forEach((node) => {\n      console.log(`(${node.row}, ${node.col})`);\n    });\n  };\n  \n\n  componentDidMount() {\n\n    const grid = getInitialGrid();\n    this.setState({ grid });\n    document.addEventListener(\"keydown\", this.handleKeyDown);\n    document.addEventListener(\"keyup\", this.handleKeyUp);\n  }\n\n  componentWillUnmount() {\n    document.removeEventListener(\"keydown\", this.handleKeyDown);\n    document.removeEventListener(\"keyup\", this.handleKeyUp);\n  }\n  \n  handleMouseDown = (row, col, e) => {\n\n    if (this.state.isAnimating) {\n      // If animation is running, do nothing\n      return;\n    }\n\n    if (!this.state.shiftKeyPressed) {\n      this.addDestinationNode(row, col);\n    } else {\n      const newGrid = getNewGridWithWallToggled(this.state.grid, row, col, e);\n      this.setState({ grid: newGrid, mouseIsPressed: true });\n    }\n  };\n\n  handleMouseEnter(row, col, e) {\n    if (this.state.isAnimating || !this.state.mouseIsPressed || !this.state.shiftKeyPressed) {return;}\n    const newGrid = getNewGridWithWallToggled(this.state.grid, row, col, e);\n    this.setState({ grid: newGrid });\n  }\n\n  handleMouseUp() {\n    this.setState({ mouseIsPressed: false });\n  }\n\n  handleMouseLeave(row, col) {\n    if (!this.state.mouseIsPressed) return;\n    this.setState({ mouseIsPressed: false });\n  }\n\n  handleKeyDown = (e) => {\n    if (e.key === \"Shift\") {\n      this.setState({ shiftKeyPressed: true });\n    }\n  };\n\n  handleKeyUp = (e) => {\n    if (e.key === \"Shift\") {\n      this.setState({ shiftKeyPressed: false });\n    }\n  };\n\n  animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder) {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          this.animateShortestPath(nodesInShortestPathOrder);\n          this.setState({ isAnimating: false });\n        }, 10 * i);\n\n        return;\n      }\n\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        const element = document.getElementById(`node-${node.row}-${node.col}`);\n\n        if (\n          element.className !== \"node node-destination\"\n        ) {\n          document.getElementById(`node-${node.row}-${node.col}`).className =\n            \"node node-visited\";\n        }\n      }, 10 * i);\n    }\n  }\n\n  animateShortestPath(nodesInShortestPathOrder) {\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      setTimeout(() => {\n        const node = nodesInShortestPathOrder[i];\n        const element = document.getElementById(`node-${node.row}-${node.col}`);\n\n        if (\n          element.className !== \"node node-destination\"\n        ) {\n          document.getElementById(`node-${node.row}-${node.col}`).className =\n            \"node node-shortest-path\";\n        }\n      }, 20 * i);\n    }\n\n    this.setState({ isAnimating: false });\n  }\n\n  isEmpty() {\n\n    const { grid } = this.state;\n\n    for (let row = 0; row < grid.length; row++) {\n\n      for (let col = 0; col < grid[0].length; col++) {\n\n        const node = grid[row][col];\n\n        console.log(`Node at row ${row} col ${col} has class ${node.className}`);\n\n        if (node.className !== \"node\" || node.className !== null) {\n\n          console.log(\"Node is not empty!\");\n          return false;\n        }\n      }\n    }\n\n    console.log(\"Grid is empty!\");\n    return true;\n  }\n\n  isDestination(node) {\n    return node.className === \"node node-destination\";\n  }\n\n  visualizeDijkstra() {\n\n    console.log(\"Starting visualizeDijkstra()...\");\n    const { grid, destinationNodes } = this.state;\n\n    if(this.isEmpty()) {\n  \n        alert(\"Please add some walls to the grid!\");\n    }\n\n\n    if(destinationNodes.length !== 2) {\n\n      alert(\"Please select two destination nodes!\");\n      return;\n\n    }\n    \n    const startNode = grid[destinationNodes[0].row][destinationNodes[0].col];\n    const finishNode = grid[destinationNodes[1].row][destinationNodes[1].col];\n    const visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n    this.animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder);\n    this.setState({ isAnimating: true });\n  }\n\n  clearGrid = () => {\n    console.log(\"Clearing grid...\");\n    \n    // Reset the grid\n    const newGrid = getInitialGrid();\n  \n    this.setState({ grid: newGrid }, () => {\n      const nodes = document.getElementsByClassName(\"node\");\n  \n      for (let i = 0; i < nodes.length; i++) {\n        const nodeClassName = nodes[i].className;\n        console.log(\"Node class name:\", nodeClassName);\n  \n        if (\n          nodeClassName !== \"node node-destination\"\n        ) {\n          nodes[i].className = \"node\"; // Reset the className of each Node\n          nodes[i].setAttribute(\"key\", `${nodes[i].id}`); // Update the key prop value of each Node\n          console.log(\"Node reset.\");\n        } else {\n          console.log(\"Node is Start or Finish\");\n          continue;\n        }\n      }\n  \n      this.setState({ destinationNodes: [] });\n      console.log(\"Destination nodes cleared.\");\n    });\n  };\n\n  clearGridExceptDestinations = () => {\n    \n    // Reset the grid\n    const newGrid = getInitialGrid();\n\n    this.setState({ grid: newGrid }, () => {\n      const nodes = document.getElementsByClassName(\"node\");\n\n      for (let i = 0; i < nodes.length; i++) {\n\n        const nodeClassName = nodes[i].className;\n\n        if (nodeClassName === \"node node-destination\") {\n\n          nodes[i].className = \"node\"; // Reset the className of each Node\n          nodes[i].setAttribute(\"key\", `${nodes[i].id}`); // Update the key prop value of each Node\n\n        } else {\n\n          console.log(\"Node is Start or Finish\");\n          continue;\n\n        }\n      }\n\n      this.setState({ destinationNodes: [] });\n    });\n  };\n\n  updateGrid = () => {\n    const { grid, startNodeRow, startNodeCol, finishNodeRow, finishNodeCol } =\n      this.state;\n    const newGrid = grid.slice(); // Create a copy of the grid array\n\n    // Remove the old start/finish nodes\n    const oldStartNode = grid.find((row) => row.find((node) => node.isStart));\n    const oldFinishNode = grid.find((row) => row.find((node) => node.isFinish));\n\n    if (oldStartNode) {\n      oldStartNode[\n        oldStartNode.findIndex((node) => node.isStart)\n      ].isStart = false;\n    }\n\n    if (oldFinishNode) {\n      oldFinishNode[\n        oldFinishNode.findIndex((node) => node.isFinish)\n      ].isFinish = false;\n    }\n\n    // Update the start and finish nodes in the newGrid array\n    newGrid[startNodeRow][startNodeCol].isStart = true;\n    newGrid[startNodeRow][startNodeCol].color = \"start\";\n    newGrid[finishNodeRow][finishNodeCol].isFinish = true;\n    newGrid[finishNodeRow][finishNodeCol].color = \"finish\";\n\n    // Update the state with the new grid array\n    this.setState({ grid: newGrid });\n  };\n\n  render() {\n    const { grid } = this.state;\n\n    return (\n      <>\n        <div id=\"header\">\n\n        <div id=\"directions\">\n            <h3>Directions:</h3>\n            click on a node to make it a destination node <br />\n            hold shift and drag to make a wall <br />\n            press the go button to visualize the path <br />\n            press the reset button to clear the grid <br />\n          </div>\n\n          <div id=\"destination-node-display\">\n            <h3>Destination Nodes:</h3>\n            {grid.map((row, rowIdx) => {\n              return (\n                <div key={rowIdx}>\n                  {row\n                    .filter((node) => node.color === \"node-destination\")\n                    .map((node, nodeIdx) => (\n                      <span key={nodeIdx}>\n                        ({node.row}, {node.col})\n                      </span>\n                    ))}\n                </div>\n              );\n            })}\n          </div>\n        </div>\n        <div className=\"grid\">\n          {grid.map((row, rowIdx) => {\n            return (\n              <div key={rowIdx}>\n                {row.map((node, nodeIdx) => {\n                  const {\n                    row,\n                    col,\n                    isDestination,\n                    isWall,\n                    isVisited,\n                    distance,\n                  } = node;\n                  return (\n                    <Node\n                      key={`${row}-${col}`}\n                      col={col}\n                      isDestination={isDestination}\n                      isWall={isWall}\n                      row={row}\n                      isVisited={isVisited}\n                      distance={distance}\n                      isAnimating={this.state.isAnimating}\n                      onMouseDown={(e) => this.handleMouseDown(row, col, e)}\n                      onMouseEnter={(e) => this.handleMouseEnter(row, col, e)}\n                      onMouseUp={() => this.handleMouseUp()}\n                    ></Node>\n                  );\n                })}\n              </div>\n            );\n          })}\n\n          <div id=\"buttons\">\n            <button onClick={() => this.visualizeDijkstra()} disabled={this.state.isAnimating}>G O</button>\n            <button onClick={() => this.clearGrid()} disabled={this.state.isAnimating}>R E S E T</button>\n          </div>\n        </div>\n      </>\n    );\n  }\n}\n\nconst getInitialGrid = () => {\n  const grid = [];\n  for (let row = 0; row < 20; row++) {\n    const currentRow = [];\n    for (let col = 0; col < 50; col++) {\n      currentRow.push(createNode(col, row));\n    }\n    grid.push(currentRow);\n  }\n  return grid;\n};\n\nconst createNode = (col, row, isStart, isDestination, color, isSelected) => {\n  return {\n    col,\n    row,\n    isStart,\n    isDestination,\n    distance: Infinity,\n    isVisited: false,\n    isWall: false,\n    previousNode: null,\n    color,\n    isSelected,\n  };\n};\n\nconst getNewGridWithWallToggled = (grid, row, col) => {\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n\n  const newNode = {\n    ...node,\n    isWall: !node.isWall,\n  };\n  newGrid[row][col] = newNode;\n\n  return newGrid;\n};\n","import React from 'react';\nimport './App.css';\nimport Engine from './Engine/Engine'\n\nfunction App() {\n\n  return (\n    \n    <div className='container'>\n      \n      <Engine></Engine>\n\n    </div>\n\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport './index.css';\nimport App from './App';\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\n\nroot.render(\n\n  <React.StrictMode>\n    <App/>\n  </React.StrictMode>\n  \n);\n"],"sourceRoot":""}